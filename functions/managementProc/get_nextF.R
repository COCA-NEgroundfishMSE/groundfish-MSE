#' @title Apply Harvest Control Rules
#' @description A general application of national standard 1 reference points. Apply harvest control rules (HCR) to generate initial advice, project stock under initial advice, update advice and finalize F. ??? This is vague and probably wrong, I should revisit.
#' 
#' The operational component of parmgt for this function is the "HCR" option
#' @template global_parmgt
#' @param parpop A named list of the following population parameters: ??? Check that this includes all items (maybe defined in get_burnF.R= assumed for this documentation or parpop=stock?)
#' \itemize{
#'   \item{sel - A vector of selectivity-at-age ???}
#'   \item{waa - A vector of weight-at-age}
#'   \item{R - A number for recruitment ??? or a vector}
#'   \item{mat - A vector of maturity ???}
#'   \item{M - A scalar of natural mortality or vector of natural mortality-at-age}
#'   \item{SSBhat - }
#'   \item{J1N - }
#'   \item{Rpar - }
#'   \item{Fhat - }
#'   \item{switch - A boolean ???}
#' }
#' @param parenv A named list containing the following:
#' \itemixe{
#'   \item{tempY - set to temp???}
#'   \item{Tanom - }
#'   \item{yrs - A vector of calendar years from firstYear to mxyear, set in processes/genAnnStructure.R}
#'   \item{yrs_temp - A vector of years from firstYear to the maximum year in the cmip5 temperature timeseries}
#'   \item{y - A number to index year loop in MSE simulation}
#' }
#' @param RPlast A vector of length 2 representing the Fmsy and Bmsy reference points that were used in the previous year of the simulation. The reason for this is so you can evaluate management procedures that only update reference points once every N number of years.
#' @param evalRP A boolean, if TRUE evaluate reference points, if FALSE default to use RPlast. Function could be simplified a little to combine RPlast and evalRP but it is pretty clear this way at least.
#' @param stockEnv Same data as stock??? why not keep the naming consistent? In get_advice() there is a stock argument but no stockEnv, which is correct?
#' @param Rfun_BmsySim A list of functions, generated by processes/Rfun_BmsySim.R ??? Still not clear to me why these functions are in a list rather than referenced directly
#'
#' @return out??? revisit structure
#' 
#' @family managementProcedure
#' 

# Parts of this documentation inherited by get_BBRP.R, get_FBRP.R, get_proj.R, get_projnolag.R. Be careful when making changes to existing functions ("@inheritParams get_nextF" borrows documentation for arguments that are listed in both get_nextF and the file being documented)

# parpop: named ist of population parameters (vectors) needed for the 
#         simulation including selectivity (sel), weight-at-age (waa),
#         recruitment (R), maturity (mat) and natural mortality (M).
#         Natural mortality can be a vector or a scalar. Vectors have
#         one value per age class.

get_nextF <- function(parmgt, 
                      parpop, 
                      parenv, 
                      RPlast, 
                      evalRP, 
                      stockEnv,
                      Rfun_BmsySim){
  # A general application of national standard 1 reference points. There
  # are different ways to grab the F reference point and the B reference
  # point and those will be implemented in get_FBRP

  if(parmgt$ASSESSCLASS == 'CAA' || parmgt$ASSESSCLASS == 'ASAP'){

    # for GOM cod, Mramp model uses M = 0.2 for status determination
    parpopF<-parpop
    parpopF$M<-rep(0.2,9)
    parpopF$switch<-FALSE
    Fref <- get_FBRP(parmgt = parmgt, parpop = parpopF, 
                     parenv = parenv, Rfun_lst = Rfun_BmsySim, 
                     stockEnv = stockEnv)
    parmgtT<-parmgt
    parpopT<-parpop
    parpopT$M<-rep(0.2,9)
    parpopT$switch<-TRUE
    parpopT$J1N<-stockEnv$J1N[1:(y-1),]
    parpopT$selC<-stockEnv$selC
    parpopT$R<-stockEnv$R[1:(y-1)]
    stockEnvT<-stockEnv
    stockEnvT$R_mis<-FALSE
    FrefT <- get_FBRP(parmgt = parmgtT, parpop = parpopT, #Also calculate the true Fmsy
                     parenv = parenv, Rfun_lst = Rfun_BmsySim, 
                     stockEnv = stockEnvT)
    
    parpopT2<-parpopT
    parpopT2$M<-rep(0.2,9)
    FrefT2 <- get_FBRP(parmgt = parmgtT, parpop = parpopT2, #Also calculate the true Fmsy
                      parenv = parenv, Rfun_lst = Rfun_BmsySim, 
                      stockEnv = stockEnvT)
    # if using forecast start the BMSY initial population at the equilibrium
    # FMSY level (before any temperature projections). This is consistent
    # with how the Fmsy is calculated.
    parpopUpdate <- parpopF
    parpopUpdateT <- parpopT
    if(parmgt$RFUN_NM == 'forecast'){
      
      parpopUpdate$J1N <- Fref$equiJ1N_MSY
      
    }
    stockEnvT$R_mis<-TRUE
    Bref <- get_BBRP(parmgt = parmgt, parpop = parpopUpdate, 
                     parenv = parenv, Rfun_lst = Rfun_BmsySim,
                     FBRP = Fref[['RPvalue']], stockEnv = stockEnv)
    
    stockEnvT<-stockEnv
    stockEnvT$R_mis<-FALSE
    BrefT <- get_BBRP(parmgt = parmgtT, parpop = parpopUpdateT, #Also calculate the true Bmsy
                     parenv = parenv, Rfun_lst = Rfun_BmsySim,
                     FBRP = FrefT[['RPvalue']], stockEnv = stockEnvT)
    parpopUpdateT2 <- parpopUpdateT
    parpopUpdateT2$M<-rep(0.2,9)
    BrefT2 <- get_BBRP(parmgt = parmgtT, parpop = parpopUpdateT2, #Also calculate the true Bmsy
                      parenv = parenv, Rfun_lst = Rfun_BmsySim,
                      FBRP = FrefT[['RPvalue']], stockEnv = stockEnvT)
    
    if(evalRP){
      FrefRPvalue <- Fref[['RPvalue']]
      BrefRPvalue <- Bref[['RPvalue']]
      FrefTRPvalue <- FrefT[['RPvalue']]
      BrefTRPvalue <- BrefT[['RPvalue']]
      FrefTRPvalue2 <- FrefT2[['RPvalue']]
      BrefTRPvalue2 <- BrefT2[['RPvalue']]
    }else{
      FrefRPvalue <- RPlast[1]
      BrefRPvalue <- RPlast[2]
      FrefTRPvalue <- FrefT[['RPvalue']]
      BrefTRPvalue <- BrefT[['RPvalue']]
      FrefTRPvalue2 <- FrefT2[['RPvalue']]
      BrefTRPvalue2 <- BrefT2[['RPvalue']]
    }
    
    # Determine whether the population is overfished and whether 
    # overfishing is occurring
    
    # otherwise just use same reference points values    
    BThresh <- BrefScalar * BrefRPvalue
    FThresh <- FrefScalar * FrefRPvalue

    overfished <- ifelse(tail(parpop$SSBhat,1) < BThresh, 1, 0)
    
    overfishing <- ifelse(tail(parpop$Fhat,1) > FrefRPvalue, 1, 0) #MDM

    if(tolower(parmgt$HCR) == 'slide'){
      F <- get_slideHCR(parpop, Fmsy=FThresh, Bmsy=BThresh)['Fadvice']

    }
    
    else if(tolower(parmgt$HCR) == 'tempslide'){
      
      F <- get_tempslideHCR(parpop, Fmsy=FThresh, Bmsy= BThresh, temp= Tanom[y])['Fadvice']
      
    }
    else if(tolower(parmgt$HCR) == 'simplethresh'){
     
      # added small value to F because F = 0 causes some estimation errors
      F <- ifelse(tail(parpop$SSBhat, 1) < BThresh, 0, FThresh)+1e-4
      
    }
    else if(tolower(parmgt$HCR) == 'constf'){
 
      F <- FThresh
      
    }
    else if(tolower(parmgt$HCR) == 'step'){
      if (y==fmyearIdx & overfished== 1){F<-FrefRPvalue*0.7}
      else if (y==fmyearIdx & overfished== 0){F<-FThresh}
      else if (y>fmyearIdx & overfished== 1){F<-FrefRPvalue*0.7}
      else if (y>fmyearIdx & overfished== 0){
        if(any(stockEnv$OFdStatus==1,na.rm=T)& tail(parpop$SSBhat,1)<BrefRPvalue){F<-FrefRPvalue*0.7}
        else{F<-FThresh}}
    }
    
    if(tolower(parmgt$projections) == 'true'){
      if ((y-fmyearIdx) %% as.numeric(tolower(parmgt$AssessFreq)) == 0){
      parmgtproj<-parmgt
      parmgtproj$RFUN_NM<-"forecast"
      catchproj<-matrix(ncol=2,nrow=100)
      parpopproj<-parpop
      parpopproj$SSBhat<-stockEnv$res$SSB
      parpopproj$R<-stockEnv$res$N.age[,1]
      parpopproj$J1N<-tail(stockEnv$res$N.age,1)
      parpopproj$catch<-stockEnv$res$catch.obs
      if(tolower(parmgt$HCR) == 'pstar'){F<-FrefRPvalue}
      if(stockEnv$waa_mis=='TRUE'){
        parpopproj$waa<-stock[[1]]$waa[1,]
      }
      for (i in 1:100){
          if(mproc[m,'Lag'] == 'TRUE'){
          catchproj[i,]<-get_proj(type = 'current',
                                  parmgt = parmgtproj, 
                                  parpop = parpopproj, 
                                  parenv = parenv, 
                                  Rfun = Rfun_BmsySim$forecast,
                                  F_val = F,
                                  ny = 200,
                                  stReportYr = 2,
                                  stockEnv = stockEnv)$sumCW
          }
          else if(mproc[m,'Lag'] == 'FALSE'){
          catchproj[i,]<-get_projnolag(type = 'current',
                                  parmgt = parmgtproj, 
                                  parpop = parpopproj, 
                                  parenv = parenv, 
                                  Rfun = Rfun_BmsySim$forecast,
                                  F_val = F,
                                  ny = 200,
                                  stReportYr = 2,
                                  stockEnv = stockEnv)$sumCW
          }
      }
        
      catchproj<-c(median(catchproj[,1]),median(catchproj[,2]))
      if(tolower(parmgt$HCR) == 'pstar'){
        calc_pstar = function(maxp, relB)#function to calculate P* based on SSB/SSBmsy
        {
          if(relB>=1) #at asymptote
          {
            P = maxp
          }
          else if(relB<=0.1)
          {
            P = 0.0
          }
          else
          {
            slope <- (maxp)/(1-0.1)
            inter <- maxp-slope
            P = inter+slope*relB
          }
          return(P)
        }
        P<-calc_pstar(0.4,tail(parpop$SSBhat,1)/BThresh)
        CV<-1
        calc_ABC <- function(OFL, P, CV)
        {
          # OFL is the median catch by fishing at Flim for the current population
          #Convert CV to sigma for lognormal dist
          sd <- sqrt(log(CV*CV+1))
          #Calculate ABC using inverse of the lognormal dist
          return(qlnorm(P, meanlog = log(OFL), sdlog = sd))
        }
        catchproj[1]<-calc_ABC(catchproj[1],P,CV)
        catchproj[2]<-calc_ABC(catchproj[2],P,CV)
      }
      if(tolower(parmgt$mincatch) == 'true'){
      if (stockEnv$stockName=='codGOM'){
        bycatch<-read.csv(paste('./data/data_raw/AssessmentHistory/codGOM_Discard.csv',sep=''))
        mincatch<-min(tail(bycatch$Discards),10)
      }
      if (stockEnv$stockName=='haddockGB'){
        bycatch<-read.csv(paste(getwd(),'/data/data_raw/AssessmentHistory/haddockGB_Discard.csv',sep=""))
        mincatch<-min(tail(bycatch$Discard),10)
      }
      if (catchproj[1]>mincatch & catchproj[2]>mincatch){mincatchcon<-0}
      if (catchproj[1]<mincatch){
        catchproj[1]<-mincatch
        mincatchcon<-1
      }
      if (catchproj[2]<mincatch){
        catchproj[2]<-mincatch
        mincatchcon<-1
      }
}
      if(tolower(mproc$varlimit) == 'true'){
        if(((catchproj[1]-(stockEnv$sumCW[y-1]*stockEnv$ob_sumCW))/catchproj[1])*100<(-20)){
          catchproj[1]<-(stockEnv$sumCW[y-1]*stockEnv$ob_sumCW)-((stockEnv$sumCW[y-1]*stockEnv$ob_sumCW)*.2)}
        if(((catchproj[1]-(stockEnv$sumCW[y-1]*stockEnv$ob_sumCW))/catchproj[1])*100>20){
          catchproj[1]<- (stockEnv$sumCW[y-1]*stockEnv$ob_sumCW)+((stockEnv$sumCW[y-1]*stockEnv$ob_sumCW)*.2)}
        if(((catchproj[2]-catchproj[1])/catchproj[2])*100<(-20)){
          catchproj[2]<- catchproj[1]-(catchproj[1]*.2)}
        if(((catchproj[2]-catchproj[1])/catchproj[2])*100>20){
          catchproj[2]<- catchproj[1]+(catchproj[1]*.2)}
      }
      Fest<-get_estF(catchproj=catchproj[1],parmgtproj=parmgtproj,parpopproj=parpopproj,parenv=parenv,Rfun=Rfun,stockEnv=stockEnv)
      if (Fest>FrefRPvalue){
        catchproj<-matrix(ncol=2,nrow=100)
        for (i in 1:100){
            catchproj[i,]<-get_proj(type = 'current',
                                    parmgt = parmgtproj, 
                                    parpop = parpopproj, 
                                    parenv = parenv, 
                                    Rfun = Rfun_BmsySim$forecast,
                                    F_val = FrefRPvalue,
                                    ny = 200,
                                    stReportYr = 2,
                                    stockEnv = stockEnv)$sumCW}
        catchproj<-c(median(catchproj[,1]),median(catchproj[,1]))
        if(tolower(mproc$varlimit) == 'true'){
          if(((catchproj[2]-catchproj[1])/catchproj[2])*100>20){
            catchproj[2]<- catchproj[1]+(catchproj[1]*.2)}
        }
      }
      F <- get_F(x = catchproj[1],
                   Nv = stockEnv$J1N[y,], 
                   slxCv = stockEnv$slxC[y,], 
                   M = stockEnv$natM[y], 
                   waav = stockEnv$waa[y,])
      }
      else{
      F <- get_F(x = stockEnv$catchproj[2],
                 Nv = stockEnv$J1N[y,], 
                 slxCv = stockEnv$slxC[y,], 
                 M = stockEnv$natM[y], 
                 waav = stockEnv$waa[y,])
      catchproj<-stockEnv$catchproj
      if (F>2){F<-2}
      }
    }
    
    if(tolower(parmgt$projections) == 'false'){catchproj<-NA}
  
    if (F>2){F<-2}#Not letting actual F go over 2
    
    out <- list(F = F, RPs = c(FrefRPvalue, BrefRPvalue,FrefTRPvalue, BrefTRPvalue,FrefTRPvalue2, BrefTRPvalue2), 
                ThresholdRPs = c(FThresh, BThresh), OFdStatus = overfished,
                OFgStatus = overfishing, catchproj=catchproj) #AEW
    
  }else if(parmgt$ASSESSCLASS == 'PLANB'){
    
    # Find the recommended level for catch in weight
    CWrec <- tail(parpop$obs_sumCW, 1) * parpop$mult
    
    #### NEXT MIGRATE THE WEIGHT TO A FISHING MORTALITY
    #### you know what the selectivity is going to be 
    #### (use the real one here) and you know what the weight is
    #### going to be (use the real one) so drive the F as hard as
    #### required in each of the age classes until you land on
    #### the desired catch biomass.
    
    # Calculate what the corresponding true F is that matches with
    # the actual biomass-at-age in the current year
    trueF <- get_F(x = CWrec,
                  Nv = parpop$Ntrue_y, 
                  slxCv = parpop$slxCtrue_y, 
                  M = parpop$Mtrue_y, 
                  waav = parpop$waatrue_y)
    
    out <- list(F = trueF, RPs = c(NA, NA), OFdStatus=NA,
                OFgStatus = NA) #AEW
    
  }else{
    
    stop('Assessment class not recognized')
    
  }
  
  return(out)
}
