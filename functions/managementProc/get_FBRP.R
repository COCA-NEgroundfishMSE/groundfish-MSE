#' @title Calculate F-based Reference points
#' @description 
#' 
#' @param parmgt A named list containing the management parameters: ??? Confirm that all columns listed
#' \itemize{
#'   \item{RFUN_NM - }
#'   \item{FREF_TYP - A string indicating the type of model that should be used to calculate the F reference point}
#'   \itemize{
#'     \item{"YPR" - Yield-per-recruit-based reference point. @seealso \code{\link{get_perRecruit}}. Basically the parameters (par) are just the reference point level. ??? May want to document options only at highest level (runSims)}
#'     \item{"SPR" - Spawning potential ratio-based refence point. @seealso \code{\link{get_perRecruit}}. Basically the parameters (par) are just the reference point level.}
#'     \item{"Mbased" - Natural mortality-based (data poor) option (see Gabriel and Mace 1999, p.42). In some cases M or some factor of M has been considered as a proxy for Fmsy.}
#'   }
#'   \item{FREF_PAR0 - A proportion describing the F level used for the reference point (e.g., 0.4 for F40% if you are
#         using SPR or 0.1 for F0.1 if you are using YPR)}
#' }
#' @param parpop A named list of the following population parameters: ??? Check that this includes all items
#' \itemize{
#'   \item{sel - A vector of selectivity-at-age ???}
#'   \item{waa - A vector of weight-at-age}
#'   \item{R - A number for recruitment ??? or a vector}
#'   \item{mat - A vector of maturity ???}
#'   \item{M - A scalar of natural mortality or vector of natural mortality-at-age}
#'   \item{SSBhat - }
#'   \item{J1N - }
#'   \item{Rpar - }
#'   \item{Fhat - }
#'   \item{switch - A boolean ???}
#' }
#' @param parenv A named list containing the following environmental information:
#' \itemize{
#'   \item{tempY - }
#'   \item{yrs - A vector of calendar years from firstYear to mxyear, set in processes/genAnnStructure.R}
#'   \item{yrs_temp - A vector of years from firstYear to the maximum year in the cmip5 temperature timeseries}
#'   \item{y - A number to index year loop in MSE simulations}
#' }
#' @param Rfun_lst A list of functions, generated by processes/Rfun_BmsySim.R
#' @param stockEnv - Same data as stock??? why not keep the naming consistent?
#' 
#' @return 
#' 
#' @family managementProcedure, regulations
#' 

get_FBRP <- function(parmgt, 
                     parpop, 
                     parenv, 
                     Rfun_lst, 
                     stockEnv){

  # Load in the recruitment function (recruitment function index is
  # found in the parmgt data frame but the actual functions are from
  # the list Rfun_BmsySim which is created in the processes folder.
  # Necessary for any forecast simulation-based approaches.

  Rfun <- Rfun_lst[[parmgt$RFUN_NM]]
  
  if(parmgt$FREF_TYP == 'YPR' | parmgt$FREF_TYP == 'SPR'){

    F <- get_perRecruit(parmgt = parmgt, parpop = parpop)$RPvalue
    
    # If using a per-recruit F-based reference point paired with a forecast
    # simulation B-based reference point you will need an starting-point
    # for the simulation -- calcaulte this assuming fishing at the F-based
    # reference point.
    if(parmgt$BREF_TYP == 'SIM' & parmgt$RFUN_NM == 'forecast'){
      # have to use the temporal window set up for the biomass reference
      # point so come up with a dummy parmgt
      parmgtTemp <- parmgt
      parmgtTemp$FREF_PAR0 <- parmgtTemp$BREF_PAR0
      parmgtTemp$FREF_PAR1 <- parmgtTemp$BREF_PAR1
      simAtF <- get_proj(type = 'FREF',
                 parmgt = parmgtTemp, 
                 parpop = parpop, 
                 parenv = parenv, 
                 Rfun = Rfun,
                 F_val = F,
                 ny = 200,
                 stReportYr = 2,
                 stockEnv = stockEnv)
  
      # Extract the equilibrium population for use in forecasts for
      # Fmsy forecast calculations and for output for Bmsy forecast
      # calculations
      
      equiJ1N_MSY <- simAtF$J1N
      
    }else{
      equiJ1N_MSY <- NULL
    }
    
  
    return(list(RPvalue = F, equiJ1N_MSY = equiJ1N_MSY))
    
  }else if(parmgt$FREF_TYP == 'FmsySim'){
   
    candF <- seq(from=0, to=1.25, by=0.01)

    # Edit the environmental parameters for the initial run so that
    # the temperature is always the current temperature. Important for
    # temperature-based BRP projections but will not make a difference
    # for hindcast projections. Temperature is length 1 -- the length
    # of the temperature anomaly is tested in get_proj.
    parenvTemp <- parenv
    parenvTemp$Tanom <- rep(parenv$Tanom[parenv$y],
                            times = length(parenv$Tanom))

    simAtF <- lapply(1:length(candF), function(x){
                     get_proj(type = 'FREF',
                              parmgt = parmgt, 
                              parpop = parpop, 
                              parenv = parenvTemp, 
                              Rfun = Rfun,
                              F_val = candF[x],
                              ny = 200,
                              stReportYr = 2,
                              stockEnv = stockEnv)})
    
    sumCW <- do.call(cbind, sapply(simAtF, '[', 'sumCW'))
    
    meanSumCW <- apply(sumCW, 2, mean)

    Fmsy <- candF[which.max(meanSumCW)]
    
    # Extract the equilibrium population (at each level of F) for use in 
    # forecasts for Fmsy forecast calculations and for output for Bmsy 
    # forecast calculations
    equiJ1N_MSY <- sapply(simAtF, '[', 'J1N')
    
    
    # If using forward projection, use the equilibrium values for population
    # size at the current temperature (simAtF) and the optimal F (Fmsy) and 
    # project forward from there. It is important to start from here because 
    # otherwise there might not be enough time in the projection to reach 
    # an equilibrium state.
  
    if(parmgt$RFUN_NM == 'forecast'){
      
      # Get the initial population using the optimal F assuming current
      # temperature anomaly (FMSY)
      
      parpopTemp <- parpop

      simAtF <- lapply(1:length(candF), function(x){
        parpopTemp$J1N <- equiJ1N_MSY[[x]]
        get_proj(type = 'FREF',
                 parmgt = parmgt, 
                 parpop = parpopTemp,
                 parenv = parenv, 
                 Rfun = Rfun,
                 F_val = candF[x],
                 stReportYr = 2,
                 stockEnv = stockEnv)})
      
      # Update the optimal states assuming variable temperature
      sumCW <- do.call(cbind, sapply(simAtF, '[', 'sumCW'))
      
      meanSumCW <- apply(sumCW, 2, mean)
 
      Fmsy <- candF[which.max(meanSumCW)]
      
    }
    

    # Warn if maximum yield did not occur within the range

    if(Fmsy %in% range(candF)){
      warning(paste0('get_FBRP: maximum yield occurs at endpoint of ',
                     'candidate F values ', '(stock = ',
                     stockEnv$stockName, ')'))
    }
    
    # Equilibrium starting conditions at MSY (used in BMSY calculations)
    equiJ1N_MSY <- equiJ1N_MSY[[which.max(meanSumCW)]]
    
    return(list(RPvalue = Fmsy, equiJ1N_MSY = equiJ1N_MSY))
    
  }else if(parmgt$FREF_TYP == 'Fmed'){
    
    slp <- get_replacement(parpop = parpop, parmgt = parmgt)
    pmtemp <- list(FREF_TYP = 'SSBR')
    ssbrGrid <- get_perRecruit(parmgt = pmtemp, parpop = parpop)$PRgrid
    F <- get_fmed(parpop = parpop, rep_slp = slp, ssbrGrid = ssbrGrid)
    
    return(list(RPvalue = F))
    
  }else{
    
    stop('get_FBRP: parmgt FREF_TYP not recognized')
    
  }
  
}
