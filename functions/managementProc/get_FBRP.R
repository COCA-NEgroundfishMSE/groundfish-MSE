#' @title Calculate F-based Reference points
#' @description 
#' 
#' The operational component of parmgt for this function are the "FREF_TYP" and "FREF_PAR0" options
#' @template global_parmgt
#' @inheritParams get_nextF
#' @param Rfun_lst A list of functions, generated by processes/Rfun_BmsySim.R
#' 
#' @return 
#' 
#' @family managementProcedure, regulations
#' 

# Parts of this documentation inherited by get_fmed.R, get_perRecruit.R, get_replacement.R

get_FBRP <- function(parmgt, 
                     parpop, 
                     parenv, 
                     Rfun_lst, 
                     stockEnv){

  # Load in the recruitment function (recruitment function index is
  # found in the parmgt data frame but the actual functions are from
  # the list Rfun_BmsySim which is created in the processes folder.
  # Necessary for any forecast simulation-based approaches.

  Rfun <- Rfun_lst[[parmgt$RFUN_NM]]
  
  if(parmgt$FREF_TYP == 'YPR' | parmgt$FREF_TYP == 'SPR'){

    F <- get_perRecruit(parmgt = parmgt, parpop = parpop)$RPvalue
    
    # If using a per-recruit F-based reference point paired with a forecast
    # simulation B-based reference point you will need an starting-point
    # for the simulation -- calcaulte this assuming fishing at the F-based
    # reference point.
    if(parmgt$BREF_TYP == 'SIM' & parmgt$RFUN_NM == 'forecast'){
      # have to use the temporal window set up for the biomass reference
      # point so come up with a dummy parmgt
      parmgtTemp <- parmgt
      parmgtTemp$FREF_PAR0 <- parmgtTemp$BREF_PAR0
      parmgtTemp$FREF_PAR1 <- parmgtTemp$BREF_PAR1
      simAtF <- get_proj(type = 'FREF',
                 parmgt = parmgtTemp, 
                 parpop = parpop, 
                 parenv = parenv, 
                 Rfun = Rfun,
                 F_val = F,
                 ny = 200,
                 stReportYr = 2,
                 stockEnv = stockEnv)
  
      # Extract the equilibrium population for use in forecasts for
      # Fmsy forecast calculations and for output for Bmsy forecast
      # calculations
      
      equiJ1N_MSY <- simAtF$J1N
      
    }else{
      equiJ1N_MSY <- NULL
    }
    
  
    return(list(RPvalue = F, equiJ1N_MSY = equiJ1N_MSY))
    
  }else if(parmgt$FREF_TYP == 'FmsySim'){
   
    candF <- seq(from=0, to=1.25, by=0.01)

    # Edit the environmental parameters for the initial run so that
    # the temperature is always the current temperature. Important for
    # temperature-based BRP projections but will not make a difference
    # for hindcast projections. Temperature is length 1 -- the length
    # of the temperature anomaly is tested in get_proj.
    parenvTemp <- parenv
    parenvTemp$Tanom <- rep(parenv$Tanom[parenv$y],
                            times = length(parenv$Tanom))

    simAtF <- lapply(1:length(candF), function(x){
                     get_proj(type = 'FREF',
                              parmgt = parmgt, 
                              parpop = parpop, 
                              parenv = parenvTemp, 
                              Rfun = Rfun,
                              F_val = candF[x],
                              ny = 200,
                              stReportYr = 2,
                              stockEnv = stockEnv)})
    
    sumCW <- do.call(cbind, sapply(simAtF, '[', 'sumCW'))
    
    meanSumCW <- apply(sumCW, 2, mean)

    Fmsy <- candF[which.max(meanSumCW)]
    
    # Extract the equilibrium population (at each level of F) for use in 
    # forecasts for Fmsy forecast calculations and for output for Bmsy 
    # forecast calculations
    equiJ1N_MSY <- sapply(simAtF, '[', 'J1N')
    
    
    # If using forward projection, use the equilibrium values for population
    # size at the current temperature (simAtF) and the optimal F (Fmsy) and 
    # project forward from there. It is important to start from here because 
    # otherwise there might not be enough time in the projection to reach 
    # an equilibrium state.
  
    if(parmgt$RFUN_NM == 'forecast'){
      
      # Get the initial population using the optimal F assuming current
      # temperature anomaly (FMSY)
      
      parpopTemp <- parpop

      simAtF <- lapply(1:length(candF), function(x){
        parpopTemp$J1N <- equiJ1N_MSY[[x]]
        get_proj(type = 'FREF',
                 parmgt = parmgt, 
                 parpop = parpopTemp,
                 parenv = parenv, 
                 Rfun = Rfun,
                 F_val = candF[x],
                 stReportYr = 2,
                 stockEnv = stockEnv)})
      
      # Update the optimal states assuming variable temperature
      sumCW <- do.call(cbind, sapply(simAtF, '[', 'sumCW'))
      
      meanSumCW <- apply(sumCW, 2, mean)
 
      Fmsy <- candF[which.max(meanSumCW)]
      
    }
    

    # Warn if maximum yield did not occur within the range

    if(Fmsy %in% range(candF)){
      warning(paste0('get_FBRP: maximum yield occurs at endpoint of ',
                     'candidate F values ', '(stock = ',
                     stockEnv$stockName, ')'))
    }
    
    # Equilibrium starting conditions at MSY (used in BMSY calculations)
    equiJ1N_MSY <- equiJ1N_MSY[[which.max(meanSumCW)]]
    
    return(list(RPvalue = Fmsy, equiJ1N_MSY = equiJ1N_MSY))
    
  }else if(parmgt$FREF_TYP == 'Fmed'){
    
    slp <- get_replacement(parpop = parpop, parmgt = parmgt, Rfun_BmsySim = Rfun_lst)
    pmtemp <- list(FREF_TYP = 'SSBR')
    ssbrGrid <- get_perRecruit(parmgt = pmtemp, parpop = parpop)$PRgrid
    F <- get_fmed(parpop = parpop, rep_slp = slp, ssbrGrid = ssbrGrid)
    
    return(list(RPvalue = F))
    
  }else{
    
    stop('get_FBRP: parmgt FREF_TYP not recognized')
    
  }
  
}
